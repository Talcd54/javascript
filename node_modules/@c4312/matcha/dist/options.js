"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const async_1 = require("./async");
const keys = new Set([
    'defer',
    'delay',
    'initCount',
    'maxTime',
    'minSamples',
    'minTime',
    'name',
    'onComplete',
    'onCycle',
    'onStart',
    'onError',
    'onReset',
    'setup',
    'teardown',
    'fn',
]);
/**
 * Benchmark options. A subset of those that Benchmark.js has, and better typed.
 */
class Options {
    constructor(options = {}) {
        for (const key of Object.keys(options)) {
            if (keys.has(key)) {
                this[key] = options[key];
            }
        }
    }
    /**
     * Creates a new set of options by simply overwriting these ones.
     */
    assign(options) {
        const next = new Options();
        for (const key of keys) {
            if (options.hasOwnProperty(key) && options[key] !== undefined) {
                next[key] = options[key];
            }
            else if (this.hasOwnProperty(key)) {
                next[key] = this[key];
            }
        }
        return next;
    }
    /**
     * Creates a new set of options by merging the `other` onto these ones.
     */
    merge(other) {
        if (!other) {
            return this;
        }
        const next = new Options();
        for (const key of keys) {
            if (this.hasOwnProperty(key)) {
                next[key] = this[key];
            }
            if (!other.hasOwnProperty(key)) {
                continue;
            }
            switch (key) {
                case 'setup':
                    {
                        const outerFn = this[key];
                        const innerFn = other[key];
                        next[key] = () => __awaiter(this, void 0, void 0, function* () {
                            outerFn && (yield async_1.runMaybeAsync(outerFn));
                            innerFn && (yield async_1.runMaybeAsync(innerFn));
                        });
                    }
                    break;
                case 'teardown':
                    {
                        const outerFn = this[key];
                        const innerFn = other[key];
                        next[key] = () => __awaiter(this, void 0, void 0, function* () {
                            innerFn && (yield async_1.runMaybeAsync(innerFn));
                            outerFn && (yield async_1.runMaybeAsync(outerFn));
                        });
                    }
                    break;
                case 'onComplete':
                case 'onCycle':
                case 'onStart':
                case 'onError':
                case 'onReset': {
                    const outerFn = this[key];
                    const innerFn = other[key];
                    next[key] = (arg) => {
                        var _a, _b;
                        (_a = innerFn) === null || _a === void 0 ? void 0 : _a(arg);
                        (_b = outerFn) === null || _b === void 0 ? void 0 : _b(arg);
                    };
                    break;
                }
                default:
                    next[key] = other[key];
            }
        }
        return next;
    }
}
exports.Options = Options;
/**
 * Empty options.
 */
Options.empty = new Options();
//# sourceMappingURL=options.js.map